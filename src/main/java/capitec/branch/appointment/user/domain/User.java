package capitec.branch.appointment.user.domain;

import capitec.branch.appointment.sharekernel.username.UsernameGenerator;
import capitec.branch.appointment.utils.Name;
import capitec.branch.appointment.utils.NamesValidator;
import capitec.branch.appointment.utils.CustomerEmail;
import capitec.branch.appointment.utils.NotBlankEmailValidator;
import capitec.branch.appointment.utils.Password;
import capitec.branch.appointment.utils.PasswordValidator;
import capitec.branch.appointment.utils.Username;
import capitec.branch.appointment.utils.ValidatorMessages;
import org.springframework.util.Assert;

import java.util.Objects;
import java.util.Optional;

/**
 * User aggregate root.
 *
 * Invariants:
 * - Username is immutable and generated by domain
 * - Email is immutable (identity)
 * - Password can only be changed through protected setter (controlled by domain services)
 * - User can be enabled/disabled and verified/unverified
 */
public class User {

    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(User.class);
    private static final NamesValidator NAME_VALIDATOR = new NamesValidator();
    private static final PasswordValidator PASSWORD_VALIDATOR = new PasswordValidator();
    private static final NotBlankEmailValidator EMAIL_VALIDATOR = new NotBlankEmailValidator();
    public static final int NAMES_FIELD_LENGTH = 2;
    @Username
    private final String username;

    @CustomerEmail
    private final String email;

    @Name
    private String firstname;

    @Name
    private String lastname;

    @Password
    private String password;

    private boolean verified;

    private boolean enabled;

    /**
     * Creates a new User with auto-generated username.
     * Used for new user registration.
     */
    public User(String email, String firstname, String lastname, String password) {

        Assert.isTrue(EMAIL_VALIDATOR.isValid(email, null), ValidatorMessages.EMAIL_MESS);
        Assert.isTrue(NAME_VALIDATOR.isValid(firstname, null), ValidatorMessages.FIRSTNAME);
        Assert.isTrue(NAME_VALIDATOR.isValid(lastname, null), ValidatorMessages.LASTNAME);
        Assert.isTrue(PASSWORD_VALIDATOR.isValid(password, null), ValidatorMessages.PASSWORD_MESS);

        this.email = email;
        this.firstname = firstname;
        this.lastname = lastname;
        this.password = password;
        this.verified = false;
        this.enabled = true;
        this.username = new UsernameGenerator().getId();

        log.debug("User created. username: {}", username);
    }
    /**
     * Reconstitutes a User from existing capitec client data.
     * Password is required as client needs to set new password for booking app.
     */
    protected User(String username, String email, String firstname, String lastname,
                   String password, boolean verified, boolean enabled) {

        Assert.isTrue(UsernameGenerator.isValid(username), ValidatorMessages.USERNAME_MESSAGE);
        Assert.isTrue(EMAIL_VALIDATOR.isValid(email, null), ValidatorMessages.EMAIL_MESS);
        Assert.isTrue(PASSWORD_VALIDATOR.isValid(password, null), ValidatorMessages.PASSWORD_MESS);
        Assert.isTrue(NAME_VALIDATOR.isValid(firstname, null), ValidatorMessages.FIRSTNAME);
        Assert.isTrue(NAME_VALIDATOR.isValid(lastname, null), ValidatorMessages.LASTNAME);

        this.username = username;
        this.email = email;
        this.firstname = firstname;
        this.lastname = lastname;
        this.password = password;
        this.verified = verified;
        this.enabled = enabled;

        log.debug("User reconstituted from existing client. username: {}", username);
    }

    /**
     * Private constructor for persistence reconstitution.
     */
    private User(String username, String email, String firstname, String lastname, boolean verified, boolean enabled) {

        Assert.isTrue(UsernameGenerator.isValid(username), ValidatorMessages.USERNAME_MESSAGE);
        Assert.isTrue(EMAIL_VALIDATOR.isValid(email, null), ValidatorMessages.EMAIL_MESS);
        Assert.isTrue(NAME_VALIDATOR.isValid(firstname, null), ValidatorMessages.FIRSTNAME);
        Assert.isTrue(NAME_VALIDATOR.isValid(lastname, null), ValidatorMessages.LASTNAME);

        this.username = username;
        this.email = email;
        this.firstname = firstname;
        this.lastname = lastname;
        this.password = null;
        this.verified = verified;
        this.enabled = enabled;
    }

    /**
     * Reconstitutes a User from existing persistence data.
     */
    public static User reconstitute(
            String username,
            String email,
            String firstname,
            String lastname,
            boolean verified,
            boolean enabled
    ) {
        return new User(username, email, firstname, lastname, verified, enabled);
    }


    @Username
    public String getUsername() {
        return username;
    }

    @CustomerEmail
    public String getEmail() {
        return email;
    }

    @Name
    public String getFirstname() {
        return firstname;
    }

    @Name
    public String getLastname() {
        return lastname;
    }

    /**
     * Returns the user's password wrapped in Optional.
     * Password may be null when user is reconstituted from persistence queries.
     * Callers must handle the Optional appropriately.
     */
    public Optional<String> getPassword() {
        return Optional.ofNullable(password);
    }

    public boolean isVerified() {
        return verified;
    }

    public boolean isEnabled() {
        return enabled;
    }

    // ==================== Domain Behavior ====================

    /**
     * Updates the user's password.
     * Protected - only domain services can change password.
     */
    protected User setPassword(@Password String password) {
        Assert.isTrue(PASSWORD_VALIDATOR.isValid(password, null), ValidatorMessages.PASSWORD_MESS);
        this.password = password;
        return this;
    }

    /**
     * Enables or disables the user account.
     */
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
        log.debug("User enabled status changed. username: {}, enabled: {}", username, enabled);
    }

    /**
     * Marks the user as verified or unverified.
     */
    public void setVerified(boolean verified) {
        this.verified = verified;
        log.debug("User verification status changed. username: {}, verified: {}", username, verified);
    }

    /**
     * Updates user's first name.
     */
    protected User setFirstname(@Name String firstname) {
        Assert.isTrue(NAME_VALIDATOR.isValid(firstname, null), ValidatorMessages.FIRSTNAME);
        this.firstname = firstname;
        return this;
    }

    /**
     * Updates user's last name.
     */
    protected User setLastname(@Name String lastname) {
        Assert.isTrue(NAME_VALIDATOR.isValid(lastname, null), ValidatorMessages.LASTNAME);
        this.lastname = lastname;
        return this;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User user)) return false;
        return Objects.equals(username, user.username) && Objects.equals(email, user.email);
    }

    @Override
    public int hashCode() {
        return Objects.hash(username, email);
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", email='" + email + '\'' +
                ", firstname='" + firstname + '\'' +
                ", lastname='" + lastname + '\'' +
                ", verified=" + verified +
                ", enabled=" + enabled +
                '}';
    }
}
